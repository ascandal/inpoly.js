/**
 * React wrapper around the framework-agnostic `MediaDeform`.
 *
 * Dynamically loads the WebGL code only on the client so that SSR
 * environments (Next.js, Remix, etc.) don’t hit “window is not defined”.
 *
 * Features
 * ──────────────────────────────────────────────────────────────────────────
 * - `onReady(app)` ­- receive the internal MediaDeform once initialized.
 * - `overlay` / `children` ­- simple DOM layer rendered above the canvas.
 */

"use client";

import React, {
    forwardRef,
    useEffect,
    useImperativeHandle,
    useRef,
    useState,
    useId,
} from "react";
import type { MediaDeform as MediaDeformType } from "../index.js";
import type {
    MediaTransitionEvent,
    MetricsEvent,
    // Slide,
    // Settings,
    MediaDeformProps,
} from "src/types/media-deform.js";

/**
 * Optional extension to allow lightweight updates without re-creation.
 * Todo: this feature does not exist yet.
 */
// type _EngineWithUpdates = MediaDeformType & {
//     setSlides?: (slides: MediaDeformProps["slides"]) => void;
//     setTextPhrase?: (text: MediaDeformProps["textPhrase"]) => void;
//     updateSettings?: (settings: MediaDeformProps["settings"]) => void;
// };

/**
 * React MediaDeform Component
 *
 * @param canvasId - ID of the canvas. Autogenerated if absent to avoid duplicate IDs
 */
export const MediaDeform = forwardRef<MediaDeformType, MediaDeformProps>(
    (
        {
            canvasId,
            width = "100%",
            height = "100%",
            className,
            style,
            settings,
            slides,
            textPhrase,
            onReady,
            onMetrics,
            onMediaTransition,
            overlay,
            children,
        },
        ref,
    ) => {
        // detachRef used for clean-up.
        const detachRef = useRef<(() => void)[]>([]);
        const canvasRef = useRef<HTMLCanvasElement | null>(null);
        const engineRef = useRef<MediaDeformType | null>(null);
        const [engine, setEngine] = useState<MediaDeformType | null>(null);

        /* expose engine via ref */
        useImperativeHandle(ref, () => engine as MediaDeformType, [engine]);

        // Generate a unique stable ID.
        // Prevents collisions in apps with multiple instances.
        const reactId = useId();
        const resolvedCanvasId = canvasId ?? `md-${reactId.replace(/:/g, "_")}`;

        // Keep latest callbacks in refs so engine listeners never go stale
        const metricsRef = useRef<MediaDeformProps["onMetrics"] | undefined>(
            undefined,
        );
        useEffect(() => {
            metricsRef.current = onMetrics;
        }, [onMetrics]);

        const transitionRef = useRef<
            MediaDeformProps["onMediaTransition"] | undefined
        >(undefined);
        useEffect(() => {
            transitionRef.current = onMediaTransition;
        }, [onMediaTransition]);

        // HMR cleanup for Vite or webpack.
        // Prevents leaked WebGL contexts during dev.
        // Safe for both ESM and CJS outputs (no bare `import.meta` in CJS).
        useEffect(() => {
            const dispose = () => engineRef.current?.destroy?.();

            // Vite (import.meta.hot) — gate behind eval so CJS builds don't touch `import.meta`.
            try {
                const meta = (0, eval)("import.meta") as
                    | { hot?: { dispose(cb: () => void): void } }
                    | undefined;
                meta?.hot?.dispose(dispose);
            } catch {
                // Not running under Vite or `import.meta` unavailable; ignore.
            }

            // webpack/Next.js via globalThis.module.hot
            const m = (
                globalThis as unknown as {
                    module?: { hot?: { dispose(cb: () => void): void } };
                }
            ).module;
            m?.hot?.dispose(dispose);
        }, []);

        // Boot-strap WebGL app on mount.
        // Updates handled separately for settings/slides/textPhrase.
        useEffect(() => {
            let cancelled = false;

            (async () => {
                if (!canvasRef.current) return;

                let app: MediaDeformType | null = null;
                try {
                    // Dynamically import to avoid bundling WebGL into the server build.
                    const { MediaDeform: MediaDeformEngine } = await import(
                        "../index.js"
                    );
                    if (cancelled) return;

                    app = await MediaDeformEngine.create(resolvedCanvasId, {
                        settings,
                        slides,
                        textPhrase,
                    });

                    // If unmounted while awaiting create(), tear down immediately.
                    if (cancelled) {
                        app.destroy?.();
                        return;
                    }

                    // Hold reference and wrap destroy to make teardown robust & idempotent
                    engineRef.current = app;
                    const origDestroy = app.destroy.bind(app);
                    app.destroy = () => {
                        // Remove listeners we registered via detachRef
                        if (detachRef.current.length) {
                            detachRef.current.forEach((fn) => fn());
                            detachRef.current = [];
                        }
                        // Delegate to engine's own cleanup
                        origDestroy();
                        // Drop references
                        engineRef.current = null;
                        setEngine(null);
                    };

                    setEngine(app);
                    onReady?.(app);

                    // forward events to props via stable handler refs
                    {
                        const h = (d: MetricsEvent) => metricsRef.current?.(d);
                        app.on("metrics", h);
                        detachRef.current.push(() => app!.off("metrics", h));
                    }
                    {
                        const h = (d: MediaTransitionEvent) =>
                            transitionRef.current?.(d);
                        app.on("mediaTransition", h);
                        detachRef.current.push(() =>
                            app!.off("mediaTransition", h),
                        );
                    }
                } catch (e) {
                    // Optional: surface via an onError prop or log in dev
                    console.warn("[MediaDeform] init failed", e);
                }
            })();

            return () => {
                cancelled = true;
                engineRef.current?.destroy?.();
            };

            // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [resolvedCanvasId]);

        // Lightweight updates without re-creating the engine
        // Todo: This feature does not exist yet.
        // useEffect(() => {
        //     const e = engineRef.current as _EngineWithUpdates | null;
        //     e?.setSlides?.(slides);
        // }, [slides]);

        // useEffect(() => {
        //     const e = engineRef.current as _EngineWithUpdates | null;
        //     e?.setTextPhrase?.(textPhrase);
        // }, [textPhrase]);

        // useEffect(() => {
        //     const e = engineRef.current as _EngineWithUpdates | null;
        //     e?.updateSettings?.(settings);
        // }, [settings]);

        return (
            <div
                style={{
                    position: "relative",
                    width,
                    height,
                }}
            >
                <canvas
                    id={resolvedCanvasId}
                    ref={canvasRef}
                    className={className}
                    style={{
                        display: "block",
                        width: "100%",
                        height: "100%",
                        touchAction: "none",
                        ...style,
                    }}
                />
                <div
                    style={{
                        position: "absolute",
                        inset: 0,
                        pointerEvents: "none",
                    }}
                >
                    {overlay ?? children}
                </div>
            </div>
        );
    },
);

export default MediaDeform;
